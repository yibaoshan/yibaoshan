
# 并发指令支持

因为 x86、ARM、RISCV 架构的指令集不同，所以本小节我们就不关注具体的指令了

抛开 CPU 平台的特性，只看共性有哪些，理解思想就行了。

### 原子操作指令

- CAS（Compare And Swap），比较并交换指令，一般用于自旋锁和无锁数据结构的实现
  - 每个平台都有对应的实现，x86 对应 CMPXCHG，ARM 是 LDREX/STREX，RISC-V 是 AMO (Atomic Memory Operation)
- 原子读写
  - Fetch-and-Add，FAA，对某个内存增加一个数量的原子操作，一般用于计数器吧
  - Test-and-Set，AI 说一般用于互斥锁实现、信号量和临界区保护

### 内存屏障指令

常见的有三种，读屏障（Load Barrier）、写屏障（Store Barrier）和全屏障（Full Barrier），用来控制指令重排序

- full 是最强的内存屏障类型，可以确保前后的内存访问顺序
- load、store，分别保证读写访问顺序

# MESI 缓存一致性协议

这部分内容了解即可

对于多核 CPU 和多级缓存读写同一块主存产生的并发安全问题，由 CPU 的缓存控制器实现的 MESI 协议保障并发安全

- 每个 CPU 核心都有自己的缓存，一般是 L1 Cache（L3 所有核心共享，L2 Cache 可能独占也可能是共享），并且拥有自己的缓存控制器。
- 总线监听机制，每个 CPU 都要通过总线嗅探（Bus Snooping）来监听总线的活动，当一个核心修改数据后会在总线上广播这个消息，其他核心的缓存控制器收到消息后更新缓存状态，改为失效或共享。
- 地址追踪机制，缓存控制器会记录数据的物理地址，知道哪个 CPU 的缓存上持有最新数据，比如 CPU1 修改了数据但还没写回，那当其他 CPU 要读取这个地址的值时，不是去主存，而是通过总线直接从 CPU1 读数据（省略了中间一些通信过程）。

MESI 这几个字母的含义

- M 修改 (Modified)，表示当前 Cache 数据有效，只是数据被自己修改了，和内存中的数据不一致，并且当前的数据只存在于本 Cache 中。
- E 独享 (Exclusive)，Cache 数据有效，并且和主存相同，并且数据只存在于本 Cache 中，其他 CPU 没有从主存读取过。
- S 共享 (Shared)，数据有效，主存相同，其他 CPU 也缓存了。
- I 无效 (Invalid)，缓存数据无效，其他 CPU 修改了。

### 举个例子🌰

接下来举个小例子说明 MESI 的工作流程，我们假设有数据 X=1 存储在主存中，现在有两个 CPU 核心要访问它：

1. 初始状态 ：
  - 内存中 X=1
  - L1、2、3 缓存中都没有 X
2. CPU1 读取到了 X 值：
  - X 被加载到 CPU1 的 L1 缓存
  - 状态标记为 E（Exclusive）独享模式
  - 数据从内存 → L3 → L2 → L1
3. CPU2 也要读取 X ：
  - X 又被加载到 CPU2 的 L1 缓存
  - 两个核心的 X 都变为 S（Shared）
  - 现在，CPU1 和 CPU2 的 L1 缓存都有 X=1
4. 转折来了，此时 CPU1 修改 X=2 ：
  - CPU1 的 X 变为 M（Modified）并在总线发送广播通知
  - CPU2 收到以后，把自己 L1 的 X 变为 I（Invalid）
  - 此时的修改发生在 L1 缓存，还未写回到 L2/L3/内存
5. CPU2 要读取 X ：
  - 发现自己的 X 是 Invalid，基于地址追踪机制，直接从 CPU1 的 L1 缓存获取最新值
  - 两个核心的 X 再次变为 Shared
  - X=2 可能这时才写回到更低级缓存

写回数据，一般有几个写回的时机

- 当前缓存满了需要替换掉某一个，被替换的就需要被写回。 写回路径可能是 L1→L2→L3→内存，也可能直接从 L1 写回到内存，这个过程完全由硬件控制，操作系统/软件层面不需要也无法干预这个过程。
- Modified 状态的数据被其他核心请求时也会，比如上面 CPU 1 有个 Modified 状态的数据，此时如果 CPU2、CPU3 要同时读取改地址数据，可能会发生
  - CPU1 会直接通过总线将数据发送给 CPU2
  - 同时 CPU1 会将数据写回到共享缓存（L3 或主存）
  - CPU3 可能直接从 CPU1 获取，也可能从共享缓存获取
  - 反正最终三个核心都会持有该数据的副本，状态也都变为 Shared