
死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象

在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去

## 死锁条件

- 互斥条件：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。
- 请求并持有条件：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。
- 不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。
- 环路等待条件：指在发生死锁时，必然存在一个线程—资源的环形链，即线程集合{T0, T1, T2, …, Tn}中的T0正在等待一个T1占用的资源，T1正在等待T2占用的资源，……Tn正在等待已被T0占用的资源

## 示例代码

```
public void main(){
    val obj1 = Object()
    val obj2 = Object()
    
    val thread1 = Thread{
        synchronized(obj1){
            synchronized(object2){
            }
        }
    }
    
    val thread2 = Thread{
        synchronized(obj2){
            synchronized(object1){
            }
        }
    }
}
```