
# xv6-book

如果发生页面错误，用户进程会被内核干掉，内核会直接玩完。

COW (copy on write)，fork 阶段把父子进程共享的物理页面映射成 **只读**，当父子进程汇总任意一个进程执行写时，触发页面错误，OS 此时再复制这个错误的页面。

# Lecture 8

顺序：

1. 虚拟内存的好处
2. 需要的信息 
3. 基本机制 
4. 懒分配 
5. 按需补零 
6. 写入时复制 
7. 按需调页 
8. 内存映射文件

本节课程套路如何利用页面错误设计虚拟内存的几个功能，比如 cow，懒加载

回顾虚拟内存的两大好处

- 隔离性，使得某一个应用程序无法意外的或者故意破坏不应该访问的内存 
- 间接性，一对一，一对多等映射，由 OS 控制

目前，xv6 的映射还是静态的，比如 fork

如果要改为动态的，我们要利用页面错误，此时你需要知道

- 错误的地址，stval 寄存器
- 错误的类型，加载、保存、跳转指令的页面错误

懒分配

- sbrk 什么都不做，p-sz 增加 n
  - 有个问题，什么时候判定要不要 +n，因为可能已经没有足够的内存
- 如果一个地址，小于 p-sz，此时才分配一个物理页

实操

1. ummap，pte 无效时
2. bbs 段，多个未初始化的全局变量和静态变量，指向的空页面
3. 按需分配，data 段可以考虑
   - 可能出现 data 段比物理内存还要大的情况