
# 一、课程简介

课程目标：

1. 理解操作系统的设计和实现。设计是指整体的结构。
2. 为了深入了解具体的工作原理，手写一个名为 XV6 的操作系统。

通常来说，操作系统共同的目标：

1. Abstraction，抽象硬件，提供硬件接口。
2. multiplex，在多个应用程序之间共用硬件资源。你可以在一个操作系统同时运行文本编辑器，程序编译器，多个数据库等等。
3. Isolation，隔离性，因为在操作系统中可能同时运行很多程序，即使程序出现了故障，多个程序之间互不干扰就变得非常重要。
4. Sharing，共享，不同的程序之间有时又想要相互影响，比如说数据交互，协同完成任务等。举个例子，我通过文本编辑器创建了一个文件，并且我希望我的编译器能读取文件。
5. Security/Permission/Access system，安全/隐私，在很多场景下，用户并不想要共享，比如你登录到了一个公共的计算机，例如Athena，你不会想要其他人来读取你的文件

# 二、操作系统的结构

常见的 OS 都有分层的设计，即：

1. 用户空间，N 个应用程序
2. 内核空间，负责提供服务接口、管理硬件资源、调度程序。
3. 硬件资源，CPU、存储器、输入输出设备等。

讲了一些系统调用 system call

# 三、Why Hard and Interesting

为什么说学习操作系统是挑战和乐趣并存的？以及为什么我们需要专门针对操作系统设置一门课程？

学习操作系统比较难的一个原因是，内核的编程环境比较困难。

1. 当你在写应用程序时，应用程序下面是操作系统，大多数情况下，他都是值得信任的。
2. 当我们在构建操作系统时，在操作系统下面就是硬件了，这些硬件通常会更难处理。

学习操作系统比较难的另一个原因是，当你在设计一个操作系统时，你需要满足一系列矛盾的需求。

1. 高效和易用，高效通常意味着操作系统需要在离硬件近的 low-level 进行操作。而易用则要求操作系统为应用程序提供抽象 的high-level 可移植接口。
2. 简单和强大，我们想要提供一个非常强大的操作系统服务，这样操作系统才能分担运行应用程序的负担。但同时，我们也想要有简单的接口。我们不想程序员看到数量巨多，复杂且难以理解的的内核接口。因为，如果他们不理解这些接口，他们就会很难使用这些接口。
3. 自由的边界
   - 你希望给与应用程序尽可能多的灵活性，你不会想要限制应用程序，所以你需要内核具备灵活的接口。
   - 但是另一方面，你的确需要在某种程度上限制应用程序，因为你会想要安全性。
   - 我们希望给程序员完全的自由，但是实际上又不能是真正的完全自由，因为我们不想要程序员能直接访问到硬件，干扰到其他的应用程序，或者干扰操作系统的行为。

> 学生提问：对于应用程序开发人员来说，他们会基于一些操作系统做开发，真正的深入理解这些操作系统有多重要？他们需要成为操作系统的专家吗？
> Robert教授：你不必成为一个专家。但是如果你花费大量时间来开发，维护并调试应用程序，你最终还是会知道大量操作系统的知识。不论你是否是有意要掌握这些知识，它们就是出现了，而你不得不去理解它们。

# 四、课程结构和资源

介绍课程安排和打分标准，略

# 五、read, write, exit系统调用

演示了一个用 read、write、exit 系统调用的组成的 copy 简单的小程序，略

# 六、open系统调用

演示用 open 函数打开了一个文件，然后写入了一些内容，最后读出来，略

# 七、Shell

简单介绍了一下 shell，就是提供给用户交互的终端接口。有意思的一点是演示了一个重定向功能

ls > out，将 ls 命令的结果重定向到 out 文件中

grep x < out ，将 out 文件中包含 x 的行输出到屏幕上

# 八、fork 进程

演示了 fork 函数

# 九、exec, wait系统调用

比较了fork 和 exec 系统调用，exec 函数会替换掉当前进程，fork 函数会创建一个新进程，然后返回两个进程的 PID。

而 wait 函数会等待子进程结束，然后返回子进程的 PID。如果一个进程没有子进程，wait 函数会返回 -1。

# 十、I/O Redirect
