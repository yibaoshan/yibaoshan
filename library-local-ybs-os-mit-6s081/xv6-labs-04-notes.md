
# Lecture 5

介绍 c 语言编译成汇编过程

trap frame

stack

- 不同方法的栈大小也不同，如果方法入参函数很多，寄存器不够用，会将入参保存到栈空间。
- 栈从下扩展
- 对于每个栈帧来说，返回地址永远在第一个
- sp，stack point 栈顶指针，指向栈顶
- fp ，frame pointer 栈底指针

# Lecture 6 Traps

trap 如何从用户到内核？

- pc 寄存器，程序计数器，记录当前执行的指令的地址
- satp，页表
- stvec，中断指令寄存器
- sepc 寄存器，trap 期间保存 pc 的值

程序切换时，需保存 CPU 中的寄存器的值到内存。

- ecall 发生时，不切换页表，这意味着，一部分内核代码（比如 syscall 入库），必须存在用户页表中
- trampoline 页面，trapframe 页面（里面有 32 个寄存器的变量），都会被映射到用户页表，但用户程序不可写入该段地址，因为他们的 pte 没有 u 标识，表示用户程序无法访问这部分内存。
- 内核在进入用户空间之前，设置 stvec 寄存器，指向 trampoline 页面开始的位置。
- ecall 指令，实际上做了三件事：
  1. 将 CPU 从普通模式切换到管理员模式。
  2. 将 PC 程序计数器寄存器保存到 sepc 寄存器。
  3. 跳转到 stvec 寄存器指向的位置。

##### 保存 32 个寄存器的值

trap 发生时，CPU 的寄存器保存的全部是用户程序的值。

内核代码在执行时，可能也需要占用寄存器，这样寄存器的值将会被覆盖，这是绝对不能发生的事情。

在执行内核代码之前，应该如何正确的保存寄存器的值？

- 如何切换到内核页表？
- 需要创建一个栈、或者查找栈，来运行需要栈空间的内核代码。 
- csrrw 指令，将 sscratch 和 a0 的值互换，从而达到保存 a0 值的效果。a0 



用户切换到内核，看起来像是函数调用，但因为有隔离的要求，过程还是比较复杂的。

# xv6-book chapter 4

每个RISC-V CPU都有一组控制寄存器，内核通过向这些寄存器写入内容来告诉CPU如何处理陷阱

- `stvec`：内核在这里写入其陷阱处理程序的地址；RISC-V跳转到这里处理陷阱。
- `sepc`：当发生陷阱时，RISC-V会在这里保存程序计数器`pc`（因为`pc`会被`stvec`覆盖）。`sret`（从陷阱返回）指令会将`sepc`复制到`pc`。内核可以写入`sepc`来控制`sret`的去向。
- `scause`： RISC-V在这里放置一个描述陷阱原因的数字。
- `sscratch`：内核在这里放置了一个值，这个值在陷阱处理程序一开始就会派上用场。
- `sstatus`：其中的**SIE**位控制设备中断是否启用。如果内核清空**SIE**，RISC-V将推迟设备中断，直到内核重新设置**SIE**。**SPP**位指示陷阱是来自用户模式还是管理模式，并控制`sret`返回的模式。

多核芯片上的每个CPU都有自己的这些寄存器集，并且在任何给定时间都可能有多个CPU在处理陷阱。

请注意，CPU不会切换到内核页表，不会切换到内核栈，也不会保存除`pc`之外的任何寄存器。内核软件必须执行这些任务。
